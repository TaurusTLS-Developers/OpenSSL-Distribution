name: Build OpenSSL 3.x
run-name: Build OpenSSL ${{ inputs.version }} via ${{ github.event_name }}

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'OpenSSL Version (e.g. 3.4.0)'
        required: true
        default: '3.4.0'

jobs:
  prepare-metadata:
    name: Prepare Build Metadata
    runs-on: ubuntu-latest
    steps:
      - name: Save Version Info
        run: echo "${{ inputs.version }}" > version.txt
      
      - name: Upload Metadata Artifact
        uses: actions/upload-artifact@v4
        with:
          name: build-metadata
          path: version.txt
          retention-days: 1 # Only needed temporarily for the publish workflow

  build:
    needs: prepare-metadata # Ensures metadata is ready before builds start
    name: ${{ matrix.os-label }} - ${{ matrix.arch }}
    runs-on: ${{ matrix.os-runner }}
    strategy:
      fail-fast: false
      matrix:
        include:
          # --- WINDOWS ---
          - os-label: Windows
            os-runner: windows-latest
            arch: x64
            target: VC-WIN64A
            vcvars: x64
          - os-label: Windows
            os-runner: windows-latest
            arch: x86
            target: VC-WIN32
            vcvars: x86
          - os-label: Windows
            os-runner: windows-11-arm
            arch: arm64ec
            target: VC-WIN64-ARM
            vcvars: arm64
            no_asm: true

          # --- LINUX ---
          - os-label: Linux
            os-runner: ubuntu-latest
            arch: x64
            target: linux-x86_64
          - os-label: Linux
            os-runner: ubuntu-latest
            arch: arm64
            target: linux-aarch64
            cross_prefix: aarch64-linux-gnu-

          # --- MACOS ---
          - os-label: macOS
            os-runner: macos-14
            arch: x64
            target: darwin64-x86_64-cc
          - os-label: macOS
            os-runner: macos-14
            arch: arm64
            target: darwin64-arm64-cc

          # --- ANDROID ---
          - os-label: Android
            os-runner: ubuntu-latest
            arch: arm64
            target: android-arm64
          - os-label: Android
            os-runner: ubuntu-latest
            arch: x86_64
            target: android-x86_64

          # --- IOS (Static Only) ---
          - os-label: iOS
            os-runner: macos-14
            arch: arm64
            target: ios64-cross
            static_only: true

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Dependencies (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential perl zip libsctp-dev
          if [ "${{ matrix.arch }}" == "arm64" ]; then
            sudo apt-get install -y gcc-aarch64-linux-gnu
          fi

      - name: Download OpenSSL Source
        shell: bash
        run: |
          curl -L -o openssl.tar.gz https://github.com/openssl/openssl/releases/download/openssl-${{ github.event.inputs.version }}/openssl-${{ github.event.inputs.version }}.tar.gz
          tar -xzf openssl.tar.gz
          mv openssl-${{ github.event.inputs.version }} src

      - name: Patch Android 16K Page Alignment
        if: matrix.os-label == 'Android'
        shell: bash
        working-directory: src
        run: |
          sed -i 's/cppflags         => "-D__ANDROID_API__=$(ANDROID_API)"/cppflags => "-D__ANDROID_API__=$(ANDROID_API) -fPIC",\n        lflags => "-Wl,-z,max-page-size=16384"/' Configurations/15-android.conf

      - name: Setup Windows Linker
        if: runner.os == 'Windows'
        shell: bash
        run: rm -f /usr/bin/link.exe 2>/dev/null || true

      # ------------------------------------------------------------------------
      # SHARED BUILD
      # ------------------------------------------------------------------------
      - name: Build Shared (Windows)
        if: runner.os == 'Windows' && matrix.static_only != true
        shell: cmd
        working-directory: src
        run: |
          call "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Auxiliary\Build\vcvarsall.bat" ${{ matrix.vcvars }}
          if "${{ matrix.arch }}"=="arm64ec" (
            perl Configure ${{ matrix.target }} --prefix=%GITHUB_WORKSPACE%\dist\shared shared no-tests no-asm "CFLAGS=/nologo /arm64EC /O1 /Zi /D_WIN32_WINNT=0x0A00" "LDFLAGS=/MACHINE:ARM64EC /DEBUG" "ARFLAGS=/MACHINE:ARM64EC"
          ) else (
            perl Configure ${{ matrix.target }} --prefix=%GITHUB_WORKSPACE%\dist\shared shared no-tests "CFLAGS=/nologo /O2 /D_WIN32_WINNT=0x0A00"
          )
          nmake
          nmake install_sw
          nmake install_html_docs || echo "Docs failed"

      - name: Build Shared (Unix/Android)
        if: runner.os != 'Windows' && matrix.static_only != true
        working-directory: src
        env:
          CROSS_COMPILE: ${{ matrix.cross_prefix }}
        shell: bash
        run: |
          EXTRA_FLAGS=""
          if [ "${{ matrix.os-label }}" == "Android" ]; then
            export ANDROID_NDK_ROOT=$ANDROID_NDK_LATEST_HOME
            export PATH=$ANDROID_NDK_ROOT/toolchains/llvm/prebuilt/linux-x86_64/bin:$PATH
            export ANDROID_API=28
          elif [ "${{ matrix.os-label }}" == "Linux" ]; then
            EXTRA_FLAGS="enable-sctp -Wl,-rpath,'\$ORIGIN'"
          fi
          
          ./Configure ${{ matrix.target }} --prefix=/usr/local shared no-tests $EXTRA_FLAGS
          make -j$(nproc)
          
          mkdir -p ../_staging
          make install_sw DESTDIR=${{ github.workspace }}/_staging
          make install_html_docs DESTDIR=${{ github.workspace }}/_staging || true
          
          mkdir -p ../dist/shared
          cp -r ../_staging/usr/local/* ../dist/shared/

      # ------------------------------------------------------------------------
      # STATIC BUILD (Added no-apps and no-module to prevent compilation errors)
      # ------------------------------------------------------------------------
      - name: Build Static (Windows)
        if: runner.os == 'Windows'
        shell: cmd
        working-directory: src
        run: |
          if exist Makefile nmake clean
          call "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Auxiliary\Build\vcvarsall.bat" ${{ matrix.vcvars }}
          if "${{ matrix.arch }}"=="arm64ec" (
            perl Configure ${{ matrix.target }} --prefix=%GITHUB_WORKSPACE%\dist\static no-shared no-apps no-module no-tests no-asm "CFLAGS=/nologo /arm64EC /O1 /D_WIN32_WINNT=0x0A00" "ARFLAGS=/MACHINE:ARM64EC" "LDFLAGS=/MACHINE:ARM64EC" || perl Configure ${{ matrix.target }} --prefix=%GITHUB_WORKSPACE%\dist\static no-shared no-module no-tests no-asm "CFLAGS=/nologo /arm64EC /O1 /D_WIN32_WINNT=0x0A00" "ARFLAGS=/MACHINE:ARM64EC" "LDFLAGS=/MACHINE:ARM64EC"
          ) else (
            perl Configure ${{ matrix.target }} --prefix=%GITHUB_WORKSPACE%\dist\static no-shared no-apps no-module no-tests "CFLAGS=/nologo /O2 /D_WIN32_WINNT=0x0A00" || perl Configure ${{ matrix.target }} --prefix=%GITHUB_WORKSPACE%\dist\static no-shared no-module no-tests "CFLAGS=/nologo /O2 /D_WIN32_WINNT=0x0A00"
          )
          nmake
          nmake install_sw

      - name: Build Static (Unix/Android/iOS)
        if: runner.os != 'Windows'
        working-directory: src
        env:
          CROSS_COMPILE: ${{ matrix.cross_prefix }}
        shell: bash
        run: |
          if [ -f Makefile ]; then make clean; fi
          
          EXTRA_FLAGS=""
          if [ "${{ matrix.os-label }}" == "Android" ]; then
            export ANDROID_NDK_ROOT=$ANDROID_NDK_LATEST_HOME
            export PATH=$ANDROID_NDK_ROOT/toolchains/llvm/prebuilt/linux-x86_64/bin:$PATH
            export ANDROID_API=28
          elif [ "${{ matrix.os-label }}" == "Linux" ]; then
            EXTRA_FLAGS="enable-sctp"
          elif [ "${{ matrix.os-label }}" == "iOS" ]; then
            export CROSS_TOP=$(xcode-select -p)/Platforms/iPhoneOS.platform/Developer
            export CROSS_SDK=iPhoneOS.sdk
          fi
          
          # Try with no-apps (3.2+), fallback to without no-apps (3.0/3.1)
          if ! ./Configure ${{ matrix.target }} --prefix=/usr/local no-shared no-apps no-module no-tests $EXTRA_FLAGS; then
            echo "Fallback: 'no-apps' option unsupported. Retrying without it..."
            ./Configure ${{ matrix.target }} --prefix=/usr/local no-shared no-module no-tests $EXTRA_FLAGS
          fi

          make -j$(nproc)
          
          mkdir -p ../_staging_static
          make install_sw DESTDIR=${{ github.workspace }}/_staging_static
          
          mkdir -p ../dist/static
          cp -r ../_staging_static/usr/local/* ../dist/static/

      # ------------------------------------------------------------------------
      # PACKAGING (Single Package, NO Debug Info, NO Symlinks)
      # ------------------------------------------------------------------------
      - name: Organize Artifacts
        shell: bash
        run: |
          # Create unified directory structure
          mkdir -p pkg/engines pkg/providers pkg/lib/static pkg/lib/import pkg/doc pkg/include
          if [ -f src/LICENSE.txt ]; then cp src/LICENSE.txt pkg/; fi

          # --- Generate README ---
          cat << 'EOF' > pkg/README.txt
          OpenSSL Distribution Package
          ============================
          
          This package contains the OpenSSL executable, shared libraries, static libraries (stripped), C headers, and documentation.
          
          Package Layout:
          ---------------
          * version.txt         - OpenSSL version in this package [non-redistributable]
          * openssl             - The OpenSSL command-line utility [redistributable/optional]
          * libcrypto / libssl  - Shared libraries[redistributable/required] 
          * install_symlinks.sh - (POSIX only) Script to restore shared library symlinks [redistributable/optional] 
          * engines/            - OpenSSL engines [redistributable/optional] 
          * providers/          - OpenSSL providers[redistributable/optional] 
          * doc/                - Developers Documentation [non-redistributable] 
          * include/            - C Header files [non-redistributable] 
          * lib/import/         - Import libraries (Windows only) [non-redistributable] 
          * lib/static/         - Static libraries (.lib / .a) [non-redistributable]
          
          Linking Instructions:
          ---------------------
          * Windows Dynamic: Link against the import libraries in `lib/import/` (which point to the DLLs in the root).
          * Windows Static:  Link against the static libraries in `lib/static/` (Compiled with /MD Dynamic CRT).
          * POSIX Dynamic:   Link directly against the shared libraries (.so / .dylib) in the root directory.
          * POSIX Static:    Link against the static archives (.a) in `lib/static/`.
          
          Deployment Instructions (Linux / macOS / Unix):
          -----------------------------------------------
          Windows file systems fail to extract Unix symbolic links. To ensure cross-platform compatibility, this archive contains only the physical shared library files.
          
          If this package includes the 'install_symlinks.sh' script, you MUST run it from the root of the extracted directory to recreate the required library symlinks (e.g., libcrypto.so -> libcrypto.so.3).
          
          $ cd <extracted_directory>
          $ sh ./install_symlinks.sh
          
          Windows Users:
          --------------
          Windows does not use symlinks for OpenSSL DLLs. You can safely ignore or delete the shell script.
          EOF

          # --- Generate Version File ---
          echo "${{ inputs.version }}" > pkg/version.txt

          # 1. Shared Libraries & Binary
          if [ "${{ matrix.static_only }}" != "true" ] && [ -d "dist/shared" ]; then
            if [ "${{ runner.os }}" == "Windows" ]; then
              cp dist/shared/bin/*.dll pkg/ 2>/dev/null || true
              cp dist/shared/bin/*.exe pkg/ 2>/dev/null || true
              cp dist/shared/lib/engines-3/*.dll pkg/engines/ 2>/dev/null || true
              cp dist/shared/lib/ossl-modules/*.dll pkg/providers/ 2>/dev/null || true
            else
              LIBDIR="dist/shared/lib"
              if [ -d "dist/shared/lib64" ]; then LIBDIR="dist/shared/lib64"; fi
              
              # Copy REAL files only (Strictly ignoring symlinks)
              for file in "$LIBDIR"/*.so* "$LIBDIR"/*.dylib*; do
                if [ -f "$file" ] &&[ ! -L "$file" ]; then
                  cp "$file" pkg/
                fi
              done
              
              if [ -f dist/shared/bin/openssl ]; then cp dist/shared/bin/openssl pkg/; fi
              
              for file in "$LIBDIR"/ossl-modules/*.so* "$LIBDIR"/ossl-modules/*.dylib*; do
                if [ -f "$file" ] && [ ! -L "$file" ]; then
                  cp "$file" pkg/providers/
                fi
              done
              
              for file in "$LIBDIR"/engines-3/*.so* "$LIBDIR"/engines-3/*.dylib*; do
                if [ -f "$file" ] && [ ! -L "$file" ]; then
                  cp "$file" pkg/engines/
                fi
              done
              
              # Generate Symlink Script
              SCRIPT_FILE="pkg/install_symlinks.sh"
              echo "#!/bin/sh" > "$SCRIPT_FILE"
              echo "echo 'Restoring shared library symlinks...'" >> "$SCRIPT_FILE"
              
              SYMLINKS_FOUND=false
              for link in "$LIBDIR"/*.so* "$LIBDIR"/*.dylib*; do
                if [ -L "$link" ]; then
                  link_name=$(basename "$link")
                  target=$(readlink "$link")
                  target_base=$(basename "$target")
                  echo "ln -sf \"$target_base\" \"$link_name\"" >> "$SCRIPT_FILE"
                  SYMLINKS_FOUND=true
                fi
              done
              
              # --- macOS Relocatability & Duplicate Cleanup ---
              if [ "${{ runner.os }}" == "macOS" ]; then
                echo "Making macOS binaries relocatable and cleaning duplicates..."
                
                rm -f pkg/libcrypto.dylib pkg/libssl.dylib
                
                echo "ln -sf libcrypto.3.dylib libcrypto.dylib" >> "$SCRIPT_FILE"
                echo "ln -sf libssl.3.dylib libssl.dylib" >> "$SCRIPT_FILE"
                SYMLINKS_FOUND=true

                for lib in pkg/lib*.dylib; do
                  if [ -f "$lib" ]; then
                    install_name_tool -id "@rpath/$(basename "$lib")" "$lib" || true
                  fi
                done
                
                find pkg -type f \( -name "*.dylib" -o -name "*.so" -o -name "openssl" \) | while read -r target; do
                  DEPS=$(otool -L "$target" 2>/dev/null | awk '/\/usr\/local\/lib\/lib/ {print $1}')
                  for dep in $DEPS; do
                    depname=$(basename "$dep")
                    if [[ "$target" == *"engines"* ]] || [[ "$target" == *"providers"* ]]; then
                      install_name_tool -change "$dep" "@loader_path/../$depname" "$target" || true
                    else
                      install_name_tool -change "$dep" "@loader_path/$depname" "$target" || true
                    fi
                  done
                  install_name_tool -add_rpath "@executable_path" "$target" 2>/dev/null || true
                  install_name_tool -add_rpath "@loader_path" "$target" 2>/dev/null || true
                done
              fi
              
              if [ "$SYMLINKS_FOUND" = true ]; then
                  chmod +x "$SCRIPT_FILE"
              else
                  rm -f "$SCRIPT_FILE"
              fi
            fi
          fi

          # 2. Static & Import Libraries (Unified Structure)
          if [ "${{ runner.os }}" == "Windows" ]; then
             cp dist/shared/lib/*.lib pkg/lib/import/ 2>/dev/null || true
             cp dist/static/lib/*.lib pkg/lib/static/ 2>/dev/null || true
          else
             SLIBDIR="dist/static/lib"
             if [ -d "dist/static/lib64" ]; then SLIBDIR="dist/static/lib64"; fi
             # POSIX static libraries go to lib/static/
             cp "$SLIBDIR"/*.a pkg/lib/static/ 2>/dev/null || true
          fi

          # 3. Strip Symbols (find is recursive, so it handles lib/static/ and lib/import/ automatically)
          if [ "${{ runner.os }}" == "Windows" ]; then
             find pkg/lib -name "*.lib" -exec llvm-strip --strip-debug {} \; 2>/dev/null || true
          else
             STRIP_CMD="strip"
             if [ "${{ matrix.arch }}" == "arm64" ] && [ "${{ runner.os }}" == "Linux" ]; then
               STRIP_CMD="${{ matrix.cross_prefix }}strip"
             fi
             find pkg -maxdepth 1 -type f \( -name "*.so*" -o -name "*.dylib" -o -name "openssl" \) -exec $STRIP_CMD --strip-unneeded {} \; 2>/dev/null || true
             find pkg/engines -type f -exec $STRIP_CMD --strip-unneeded {} \; 2>/dev/null || true
             find pkg/providers -type f -exec $STRIP_CMD --strip-unneeded {} \; 2>/dev/null || true
             find pkg/lib -name "*.a" -exec $STRIP_CMD --strip-debug {} \; 2>/dev/null || true
          fi

          # 4. Headers & Docs
          cp -r dist/static/include/* pkg/include/ 2>/dev/null || true
          if [ -d "dist/shared/html" ]; then cp -r dist/shared/html/* pkg/doc/ 2>/dev/null || true; fi
          if [ -d "dist/static/html" ]; then cp -r dist/static/html/* pkg/doc/ 2>/dev/null || true; fi
          if [ -d "dist/shared/share/doc/openssl/html" ]; then cp -r dist/shared/share/doc/openssl/html/* pkg/doc/ 2>/dev/null || true; fi

          # 5. Cleanup empty folders (This will safely remove pkg/lib/import on POSIX)
          for i in {1..3}; do find pkg -type d -empty -delete 2>/dev/null || true; done

      # ------------------------------------------------------------------------
      # FINAL PACKING
      # ------------------------------------------------------------------------
      - name: Create Final Archive
        shell: bash
        run: |
          BASE_NAME="openssl-${{ inputs.version }}-${{ matrix.os-label }}-${{ matrix.arch }}"
          if [ ! -d "pkg" ] ||[ -z "$(ls -A "pkg")" ]; then exit 0; fi
          
          if [ "${{ runner.os }}" == "Windows" ]; then
            (cd pkg && 7z a -tzip "../${BASE_NAME}.zip" .)
          else
            (cd pkg && zip -r "../${BASE_NAME}.zip" .)
          fi
          
          echo "ARCHIVE_FILE=${BASE_NAME}.zip" >> $GITHUB_ENV

      # ------------------------------------------------------------------------
      # FINAL UPLOAD
      # ------------------------------------------------------------------------
      - name: Upload Artifact
        uses: actions/upload-artifact@v7
        with:
          name: openssl-${{ inputs.version }}-${{ matrix.os-label }}-${{ matrix.arch }}
          path: ${{ env.ARCHIVE_FILE }}
          archive: false

name: Build OpenSSL 3.x
run-name: Build OpenSSL ${{ inputs.version }} via ${{ github.event_name }}

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'OpenSSL Version (e.g. 3.4.0)'
        required: true
        default: '3.4.0'

jobs:
  build:
    name: ${{ matrix.os-label }} - ${{ matrix.arch }}
    runs-on: ${{ matrix.os-runner }}
    strategy:
      fail-fast: false
      matrix:
        include:
          # --- WINDOWS ---
#          - os-label: Windows
#            os-runner: windows-latest
#            arch: x64
#            target: VC-WIN64A
#            vcvars: x64
#          - os-label: Windows
#            os-runner: windows-latest
#            arch: x86
#            target: VC-WIN32
#            vcvars: x86
#          - os-label: Windows
#            os-runner: windows-11-arm
#            arch: arm64ec
#            target: VC-WIN64-ARM
#            vcvars: arm64
#            no_asm: true

          # --- LINUX ---
          - os-label: Linux
            os-runner: ubuntu-latest
            arch: x64
            target: linux-x86_64
          - os-label: Linux
            os-runner: ubuntu-latest
            arch: arm64
            target: linux-aarch64
            cross_prefix: aarch64-linux-gnu-

          # --- MACOS ---
          - os-label: macOS
            os-runner: macos-14
            arch: x64
            target: darwin64-x86_64-cc
          - os-label: macOS
            os-runner: macos-14
            arch: arm64
            target: darwin64-arm64-cc

          # --- ANDROID ---
          - os-label: Android
            os-runner: ubuntu-latest
            arch: arm64
            target: android-arm64
          - os-label: Android
            os-runner: ubuntu-latest
            arch: x86_64
            target: android-x86_64

          # --- IOS (Static Only) ---
          - os-label: iOS
            os-runner: macos-14
            arch: arm64
            target: ios64-cross
            static_only: true

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Dependencies (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential perl zip libsctp-dev
          if [ "${{ matrix.arch }}" == "arm64" ]; then
            sudo apt-get install -y gcc-aarch64-linux-gnu
          fi

      - name: Download OpenSSL Source
        shell: bash
        run: |
          curl -L -o openssl.tar.gz https://github.com/openssl/openssl/releases/download/openssl-${{ github.event.inputs.version }}/openssl-${{ github.event.inputs.version }}.tar.gz
          tar -xzf openssl.tar.gz
          mv openssl-${{ github.event.inputs.version }} src

      - name: Patch Android 16K Page Alignment
        if: matrix.os-label == 'Android'
        shell: bash
        working-directory: src
        run: |
          sed -i 's/cppflags         => "-D__ANDROID_API__=$(ANDROID_API)"/cppflags => "-D__ANDROID_API__=$(ANDROID_API) -fPIC",\n        lflags => "-Wl,-z,max-page-size=16384"/' Configurations/15-android.conf

      - name: Setup Windows Linker
        if: runner.os == 'Windows'
        shell: bash
        run: rm -f /usr/bin/link.exe 2>/dev/null || true

      # ------------------------------------------------------------------------
      # SHARED BUILD
      # ------------------------------------------------------------------------
      - name: Build Shared (Windows)
        if: runner.os == 'Windows' && matrix.static_only != true
        shell: cmd
        working-directory: src
        run: |
          call "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Auxiliary\Build\vcvarsall.bat" ${{ matrix.vcvars }}
          if "${{ matrix.arch }}"=="arm64ec" (
            perl Configure ${{ matrix.target }} --prefix=%GITHUB_WORKSPACE%\dist\shared shared no-tests no-asm "CFLAGS=/nologo /arm64EC /O1 /Zi /D_WIN32_WINNT=0x0A00" "LDFLAGS=/MACHINE:ARM64EC /DEBUG" "ARFLAGS=/MACHINE:ARM64EC"
          ) else (
            perl Configure ${{ matrix.target }} --prefix=%GITHUB_WORKSPACE%\dist\shared shared no-tests "CFLAGS=/nologo /O2 /D_WIN32_WINNT=0x0A00"
          )
          nmake
          nmake install_sw
          nmake install_html_docs || echo "Docs failed"

      - name: Build Shared (Unix/Android)
        if: runner.os != 'Windows' && matrix.static_only != true
        working-directory: src
        env:
          CROSS_COMPILE: ${{ matrix.cross_prefix }}
        shell: bash
        run: |
          EXTRA_FLAGS=""
          if [ "${{ matrix.os-label }}" == "Android" ]; then
            export ANDROID_NDK_ROOT=$ANDROID_NDK_LATEST_HOME
            export PATH=$ANDROID_NDK_ROOT/toolchains/llvm/prebuilt/linux-x86_64/bin:$PATH
            export ANDROID_API=28
          elif [ "${{ matrix.os-label }}" == "Linux" ]; then
            EXTRA_FLAGS="enable-sctp -Wl,-rpath,'\$ORIGIN'"
          fi
          
          ./Configure ${{ matrix.target }} --prefix=/usr/local shared no-tests $EXTRA_FLAGS
          make -j$(nproc)
          
          mkdir -p ../_staging
          make install_sw DESTDIR=${{ github.workspace }}/_staging
          make install_html_docs DESTDIR=${{ github.workspace }}/_staging || true
          
          mkdir -p ../dist/shared
          cp -r ../_staging/usr/local/* ../dist/shared/

      # ------------------------------------------------------------------------
      # STATIC BUILD (Added no-apps and no-module to prevent compilation errors)
      # ------------------------------------------------------------------------
      - name: Build Static (Windows)
        if: runner.os == 'Windows'
        shell: cmd
        working-directory: src
        run: |
          if exist Makefile nmake clean
          call "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Auxiliary\Build\vcvarsall.bat" ${{ matrix.vcvars }}
          if "${{ matrix.arch }}"=="arm64ec" (
            perl Configure ${{ matrix.target }} --prefix=%GITHUB_WORKSPACE%\dist\static no-shared no-apps no-module no-tests no-asm "CFLAGS=/nologo /arm64EC /O1 /D_WIN32_WINNT=0x0A00" "ARFLAGS=/MACHINE:ARM64EC" "LDFLAGS=/MACHINE:ARM64EC"
          ) else (
            perl Configure ${{ matrix.target }} --prefix=%GITHUB_WORKSPACE%\dist\static no-shared no-apps no-module no-tests "CFLAGS=/nologo /O2 /D_WIN32_WINNT=0x0A00"
          )
          nmake
          nmake install_sw

      - name: Build Static (Unix/Android/iOS)
        if: runner.os != 'Windows'
        working-directory: src
        env:
          CROSS_COMPILE: ${{ matrix.cross_prefix }}
        shell: bash
        run: |
          if [ -f Makefile ]; then make clean; fi
          
          EXTRA_FLAGS=""
          if [ "${{ matrix.os-label }}" == "Android" ]; then
            export ANDROID_NDK_ROOT=$ANDROID_NDK_LATEST_HOME
            export PATH=$ANDROID_NDK_ROOT/toolchains/llvm/prebuilt/linux-x86_64/bin:$PATH
            export ANDROID_API=28
          elif [ "${{ matrix.os-label }}" == "Linux" ]; then
            EXTRA_FLAGS="enable-sctp"
          elif [ "${{ matrix.os-label }}" == "iOS" ]; then
            export CROSS_TOP=$(xcode-select -p)/Platforms/iPhoneOS.platform/Developer
            export CROSS_SDK=iPhoneOS.sdk
          fi
          
          ./Configure ${{ matrix.target }} --prefix=/usr/local no-shared no-apps no-module no-tests $EXTRA_FLAGS
          make -j$(nproc)
          
          mkdir -p ../_staging_static
          make install_sw DESTDIR=${{ github.workspace }}/_staging_static
          
          mkdir -p ../dist/static
          cp -r ../_staging_static/usr/local/* ../dist/static/

      # ------------------------------------------------------------------------
      # PACKAGING (Single Package, NO Debug Info, NO Symlinks)
      # ------------------------------------------------------------------------
      - name: Organize Artifacts
        shell: bash
        run: |
          mkdir -p pkg/engines pkg/providers pkg/lib pkg/doc pkg/include
          if [ -f src/LICENSE.txt ]; then cp src/LICENSE.txt pkg/; fi

          # --- Generate README ---
          cat << 'EOF' > pkg/README.txt
          OpenSSL Distribution Package
          ============================
          
          This package contains the OpenSSL executable, shared libraries, static libraries (stripped), C headers, and documentation.
          
          Package Layout:
          ---------------
          * openssl        - The OpenSSL command-line utility
          * libcrypto / libssl - Shared libraries
          * lib/           - Static libraries
          * include/       - C Header files
          * engines/       - OpenSSL engines
          * providers/     - OpenSSL providers
          * doc/           - HTML Documentation
          * install_symlinks.sh - (POSIX only) Script to restore shared library symlinks
          
          Deployment Instructions (Linux / macOS / Unix):
          -----------------------------------------------
          Windows file systems often fail to extract Unix symbolic links. To ensure cross-platform compatibility, this archive contains only the physical shared library files.
          
          If this package includes the 'install_symlinks.sh' script, you MUST run it from the root of the extracted directory to recreate the required library symlinks (e.g., libcrypto.so -> libcrypto.so.3).
          
          $ cd <extracted_directory>
          $ ./install_symlinks.sh
          
          Windows Users:
          --------------
          Windows does not use symlinks for OpenSSL DLLs. You can safely ignore or delete the shell script.
          EOF

          # 1. Shared Libraries & Binary
          if [ "${{ matrix.static_only }}" != "true" ] && [ -d "dist/shared" ]; then
            if [ "${{ runner.os }}" == "Windows" ]; then
              cp dist/shared/bin/*.dll pkg/ 2>/dev/null || true
              cp dist/shared/bin/*.exe pkg/ 2>/dev/null || true
              cp dist/shared/lib/engines-3/*.dll pkg/engines/ 2>/dev/null || true
              cp dist/shared/lib/ossl-modules/*.dll pkg/providers/ 2>/dev/null || true
            else
              LIBDIR="dist/shared/lib"
              if [ -d "dist/shared/lib64" ]; then LIBDIR="dist/shared/lib64"; fi
              
              # Copy REAL files only (Strictly ignoring symlinks)
              for file in "$LIBDIR"/*.so* "$LIBDIR"/*.dylib*; do
                if [ -f "$file" ] && [ ! -L "$file" ]; then
                  cp "$file" pkg/
                fi
              done
              
              if [ -f dist/shared/bin/openssl ]; then cp dist/shared/bin/openssl pkg/; fi
              
              for file in "$LIBDIR"/ossl-modules/*.so* "$LIBDIR"/ossl-modules/*.dylib*; do
                if [ -f "$file" ] && [ ! -L "$file" ]; then
                  cp "$file" pkg/providers/
                fi
              done
              
              for file in "$LIBDIR"/engines-3/*.so* "$LIBDIR"/engines-3/*.dylib*; do
                if [ -f "$file" ] && [ ! -L "$file" ]; then
                  cp "$file" pkg/engines/
                fi
              done
              
              # Generate Symlink Script
              SCRIPT_FILE="pkg/install_symlinks.sh"
              echo "#!/bin/sh" > "$SCRIPT_FILE"
              echo "echo 'Restoring shared library symlinks...'" >> "$SCRIPT_FILE"
              
              SYMLINKS_FOUND=false
              
              # Standard POSIX symlink detection
              for link in $(find "$LIBDIR" -maxdepth 1 -type l \( -name "*.so*" -o -name "*.dylib" \)); do
                  link_name=$(basename "$link")
                  target=$(readlink "$link")
                  target_base=$(basename "$target")
                  echo "ln -sf \"$target_base\" \"$link_name\"" >> "$SCRIPT_FILE"
                  SYMLINKS_FOUND=true
              done
              
              # --- macOS Relocatability & Duplicate Cleanup ---
              if [ "${{ runner.os }}" == "macOS" ]; then
                echo "Making macOS binaries relocatable..."
                
                # 1. Fix the ID of the main shared libraries
                for lib in pkg/lib*.dylib; do
                  if [ -f "$lib" ]; then
                    install_name_tool -id "@rpath/$(basename "$lib")" "$lib" || true
                  fi
                done
                
                # 2. Fix dependencies in all binaries (executable, dylibs, engines, providers)
                find pkg -type f \( -name "*.dylib" -o -name "*.so" -o -name "openssl" \) | while read -r target; do
                  # Use awk instead of grep to avoid exit code 1 when no matches are found
                  DEPS=$(otool -L "$target" 2>/dev/null | awk '/\/usr\/local\/lib\/lib/ {print $1}')
                  for dep in $DEPS; do
                    depname=$(basename "$dep")
                    # Engines/providers are in subfolders, so they need ../ to find the root libs
                    if [[ "$target" == *"engines"* ]] || [[ "$target" == *"providers"* ]]; then
                      install_name_tool -change "$dep" "@loader_path/../$depname" "$target" || true
                    else
                      install_name_tool -change "$dep" "@loader_path/$depname" "$target" || true
                    fi
                  done
                  # Ensure the binary knows to look in the current directory
                  install_name_tool -add_rpath "@executable_path" "$target" 2>/dev/null || true
                  install_name_tool -add_rpath "@loader_path" "$target" 2>/dev/null || true
                done
                
                # 3. Clean up the duplicate unversioned dylibs to save space
                rm -f pkg/libcrypto.dylib pkg/libssl.dylib
                
                # 4. Force script to create the symlinks
                echo "ln -sf libcrypto.3.dylib libcrypto.dylib" >> "$SCRIPT_FILE"
                echo "ln -sf libssl.3.dylib libssl.dylib" >> "$SCRIPT_FILE"
                SYMLINKS_FOUND=true
              fi
              
              if [ "$SYMLINKS_FOUND" = true ]; then
                  chmod +x "$SCRIPT_FILE"
              else
                  rm -f "$SCRIPT_FILE"
              fi
            fi
          fi

          # 2. Static Libraries
          if [ "${{ runner.os }}" == "Windows" ]; then
             cp dist/static/lib/*.lib pkg/lib/ 2>/dev/null || true
             cp dist/shared/lib/*.lib pkg/lib/ 2>/dev/null || true
          else
             SLIBDIR="dist/static/lib"
             if [ -d "dist/static/lib64" ]; then SLIBDIR="dist/static/lib64"; fi
             cp "$SLIBDIR"/*.a pkg/lib/ 2>/dev/null || true
          fi

          # 3. Strip Symbols (Unix)
          if [ "${{ runner.os }}" != "Windows" ]; then
             STRIP_CMD="strip"
             if [ "${{ matrix.arch }}" == "arm64" ] && [ "${{ runner.os }}" == "Linux" ]; then
               STRIP_CMD="${{ matrix.cross_prefix }}strip"
             fi
             find pkg -maxdepth 1 -type f \( -name "*.so*" -o -name "*.dylib" -o -name "openssl" \) -exec $STRIP_CMD --strip-unneeded {} \; 2>/dev/null || true
             find pkg/engines -type f -exec $STRIP_CMD --strip-unneeded {} \; 2>/dev/null || true
             find pkg/providers -type f -exec $STRIP_CMD --strip-unneeded {} \; 2>/dev/null || true
             find pkg/lib -name "*.a" -exec $STRIP_CMD --strip-debug {} \; 2>/dev/null || true
          fi

          # 4. Headers & Docs
          cp -r dist/static/include/* pkg/include/ 2>/dev/null || true
          if [ -d "dist/shared/html" ]; then cp -r dist/shared/html/* pkg/doc/ 2>/dev/null || true; fi
          if [ -d "dist/static/html" ]; then cp -r dist/static/html/* pkg/doc/ 2>/dev/null || true; fi
          if [ -d "dist/shared/share/doc/openssl/html" ]; then cp -r dist/shared/share/doc/openssl/html/* pkg/doc/ 2>/dev/null || true; fi

          # 5. Cleanup empty folders
          for i in {1..3}; do find pkg -type d -empty -delete 2>/dev/null || true; done

      # ------------------------------------------------------------------------
      # FINAL UPLOAD (Handled natively by GitHub Actions)
      # ------------------------------------------------------------------------
      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: openssl-${{ inputs.version }}-${{ matrix.os-label }}-${{ matrix.arch }}
          path: pkg/